---
title: 'ğŸ˜„ TSå…¨é¢è¿›é˜¶æŒ‡å—'
date: '2023-02-14'
tags: ['Typescript']
draft: false
summary: 'ç±»å‹ç¼–ç¨‹'
---

### **ä½¿ç”¨Â Callable Interfaceæ¥æè¿°ä¸€ä¸ªå‡½æ•°çš„ç»“æ„**

```jsx
// æè¿°ä¸€ä¸ªå‡½æ•°çš„ç»“æ„
interface FuncFooStruct {
  (name: string): number;
}
const printName: FuncFooStruct = function (name: string): number {
  console.log(name);
  return 1;
};
printName('tanyongjia');

// æè¿°é‡è½½å‡½æ•°çš„çš„ç»“æ„
interface Overloaded {
    (foo: string): string
    (foo: number): number
}

// example implementation
function stringOrNumber(foo: number): number;
function stringOrNumber(foo: string): string;
function stringOrNumber(foo: any): any {
    if (typeof foo === 'number') {
        return foo * foo;
    } else if (typeof foo === 'string') {
        return `hello ${foo}`;
    }
}

const overloaded: Overloaded = stringOrNumber;

// example usage
const str = overloaded(''); // type of `str` is inferred as `string`
const num = overloaded(123); // type of `num` is inferred as `number`
```

**ä½¿ç”¨Â Newable Interfaceæ¥æè¿°ä¸€ä¸ªç±»çš„ç»“æ„**

```tsx
// æè¿°ä¸€ä¸ªç±»çš„ç»“æ„ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚ä½•ä½¿ç”¨interfaceæè¿°ä¸€ä¸ªå¸¦æœ‰constructor(name: string)çš„ç±»
interface ComesFromString {
    name: string;
}

interface StringConstructable {
    new(n: string): ComesFromString;
}

class MadeFromString implements ComesFromString {
    constructor (public name: string) {
        console.log('ctor invoked');
    }
}

function makeObj(n: StringConstructable) {
    return new n('hello!');
}

console.log(makeObj(MadeFromString).name);

```

This creates an actual constraint for what you can invokeÂ `makeObj`Â with:

```
class Other implements ComesFromString {
    constructor (public name: string, count: number) {
    }
}

makeObj(Other); // Error! Other's constructor doesn't match StringConstructable
```

## ç±»å‹å·¥å…·

å«ä¹‰ï¼šå¯¹ç±»å‹è¿›è¡Œå¤„ç†çš„å·¥å…·

åˆ†ç±»ï¼š1. ç”±ä½¿ç”¨æ–¹å¼æ¥åˆ†ç±»ï¼šæ“ä½œç¬¦ï¼›å…³é”®å­—ï¼›ä¸“ç”¨è¯­æ³•ï¼›

1. ç”±ä½¿ç”¨ç›®çš„åˆ†ç±»ï¼šç±»å‹åˆ›å»ºï¼›ç±»å‹å®‰å…¨ä¿æŠ¤ï¼›

å·¥å…·ç±»å‹çš„ä¸»è¦æ„ä¹‰ï¼šåŸºäºä¼ å…¥çš„æ³›å‹å‘ä½è¿›è¡Œå„ç§ç±»å‹çš„å¤„ç†

### **ç´¢å¼•ç±»å‹**

å«ä¹‰ï¼šä¸æ˜¯ç‰¹å®šçš„ä¸€ç§ç±»å‹å·¥å…·ï¼Œè€Œæ˜¯ä¸‰ç§ç‹¬ç«‹çš„ç±»å‹å·¥å…·ç»„æˆï¼šç´¢å¼•ç­¾åç±»å‹ï¼›ç´¢å¼•ç±»å‹æŸ¥è¯¢ï¼›ç´¢å¼•ç±»å‹è®¿é—®

ç´¢å¼•ç­¾åç±»å‹ï¼šé€šè¿‡æ¥å£æˆ–è€…ç±»å‹åˆ«åä¸­ï¼Œå¿«é€Ÿå£°æ˜ä¸€ä¸ªé”®å€¼ç±»å‹ä¸€è‡´çš„ç±»å‹ç»“æ„

`interface IProps: {`

`[key: string]: string`

`}`

ç´¢å¼•ç±»å‹æŸ¥è¯¢ï¼šé€šè¿‡å…³é”®å­—keyofï¼Œå°†ç±»å‹ä¸­çš„é”®è½¬æ¢ä¸ºå¯¹åº”å­—é¢é‡ç±»å‹ï¼Œå¹¶ç»„æˆè”åˆç±»å‹

`interface IProps: {`

`key: string,`

`123: string,`

`}`

`type Keys = keyof IProps` 

`// 'key' || 123`

ç´¢å¼•ç±»å‹è®¿é—®ï¼šä»¥IProps[â€™123â€™]ç±»ä¼¼çš„æ–¹å¼ï¼Œé€šè¿‡é”®çš„å­—ç¬¦ä¸²å­—é¢é‡è®¿é—®ç›¸åº”é”®å€¼çš„ç±»å‹

`interface IProps: {`

`key: string,`

`123: string,`

`}`

`type Keys = IProps['key']` 

`// string`

### **æ˜ å°„ç±»å‹**

å«ä¹‰ï¼šé€šè¿‡å…³é”®å­—inï¼ŒåŸºäºé”®åæ˜ å°„åˆ°å¯¹åº”çš„é”®å€¼ç±»å‹ä¸Š

```fsharp
type Stringify<T> = {
  [K in keyof T]: string;
};
interface IProps {
	name: string,
	age: number
}
type IProps2 = Stringify<IProps>;
// {name: string, age: string}

type Clone<T> = {
  [K in keyof T]: T[K];
};
// æ˜ å°„ç±»å‹ã€ç´¢å¼•ç±»å‹è®¿é—®ã€ç´¢å¼•ç±»å‹æŸ¥è¯¢
```

### **å„ç§ç±»å‹å·¥å…·çš„å«ä¹‰ä¸ç”¨å¤„**

| ç±»å‹å·¥å…· | åˆ›å»ºæ–°ç±»å‹çš„æ–¹å¼ | å¸¸è§æ­é… |
| --- | --- | --- |
| ç±»å‹åˆ«åï¼ˆType Aliasï¼‰ | å°†ä¸€ç»„ç±»å‹/ç±»å‹ç»“æ„å°è£…ï¼Œä½œä¸ºä¸€ä¸ªæ–°çš„ç±»å‹ | è”åˆç±»å‹ã€æ˜ å°„ç±»å‹ |
| å·¥å…·ç±»å‹ï¼ˆTool Typeï¼‰ | åœ¨ç±»å‹åˆ«åçš„åŸºç¡€ä¸Šï¼ŒåŸºäºæ³›å‹å»åŠ¨æ€åˆ›å»ºæ–°ç±»å‹ | åŸºæœ¬æ‰€æœ‰ç±»å‹å·¥å…· |
| è”åˆç±»å‹ï¼ˆUnion Typeï¼‰ | åˆ›å»ºä¸€ç»„ç±»å‹é›†åˆï¼Œæ»¡è¶³å…¶ä¸­ä¸€ä¸ªç±»å‹å³æ»¡è¶³è¿™ä¸ªè”åˆç±»å‹ï¼ˆ||ï¼‰ | ç±»å‹åˆ«åã€å·¥å…·ç±»å‹ |
| äº¤å‰ç±»å‹ï¼ˆIntersection Typeï¼‰ | åˆ›å»ºä¸€ç»„ç±»å‹é›†åˆï¼Œæ»¡è¶³å…¶ä¸­æ‰€æœ‰ç±»å‹æ‰æ»¡è¶³æ˜ å°„è”åˆç±»å‹ï¼ˆ&&ï¼‰ | ç±»å‹åˆ«åã€å·¥å…·ç±»å‹ |
| ç´¢å¼•ç­¾åç±»å‹ï¼ˆIndex Signature Typeï¼‰ | å£°æ˜ä¸€ä¸ªæ‹¥æœ‰ä»»æ„å±æ€§ï¼Œé”®å€¼ç±»å‹ä¸€è‡´çš„æ¥å£ç»“æ„ | æ˜ å°„ç±»å‹ |
| ç´¢å¼•ç±»å‹æŸ¥è¯¢ï¼ˆIndexed Type Queryï¼‰ | ä»ä¸€ä¸ªæ¥å£ç»“æ„ï¼Œåˆ›å»ºä¸€ä¸ªç”±å…¶é”®åå­—ç¬¦ä¸²å­—é¢é‡ç»„æˆçš„è”åˆç±»å‹ | æ˜ å°„ç±»å‹ |
| ç´¢å¼•ç±»å‹è®¿é—®ï¼ˆIndexed Access Typeï¼‰ | ä»ä¸€ä¸ªæ¥å£ç»“æ„ï¼Œä½¿ç”¨é”®åå­—ç¬¦ä¸²å­—é¢é‡è®¿é—®åˆ°å¯¹åº”çš„é”®å€¼ç±»å‹ | ç±»å‹åˆ«åã€æ˜ å°„ç±»å‹ |
| æ˜ å°„ç±»å‹ ï¼ˆMapping Typeï¼‰ | ä»ä¸€ä¸ªè”åˆç±»å‹ä¾æ¬¡æ˜ å°„åˆ°å…¶å†…éƒ¨çš„æ¯ä¸€ä¸ªç±»å‹ | å·¥å…·ç±»å‹ |

ä»¥ä¸Šçš„ç±»å‹å·¥å…·éƒ½æœ‰**ç±»å‹åˆ›å»º**çš„ä½œç”¨ï¼Œè¿˜æœ‰ç±»å‹å·¥å…·æœ‰**ç±»å‹å®‰å…¨ä¿æŠ¤**çš„ä½œç”¨ï¼š**ç±»å‹æŸ¥è¯¢æ“ä½œç¬¦**
ä¸**ç±»å‹å®ˆå«**

### **ç±»å‹æŸ¥è¯¢æ“ä½œç¬¦**

å«ä¹‰ï¼šåœ¨**ç±»å‹æ ‡æ³¨**æˆ–è€…**ç±»å‹å·¥å…·**ä¸­ä½¿ç”¨å…³é”®å­—keyofå¯ä»¥ç”¨äºç±»å‹æŸ¥è¯¢

`const str = â€˜123â€™`

`type Str = typeof str // 123`

ç±»å‹æŸ¥è¯¢æ“ä½œç¬¦åé¢ä¸å…è®¸è·Ÿç€æ“ä½œç¬¦ï¼Œæ˜¯ä¸ºäº†ä½¿å¾—é€»è¾‘å±‚ä¸ç±»å‹å±‚åˆ†ç¦»ï¼Œé€šè¿‡ä»¥æœ€çª„çš„æ¨å¯¼ç¨‹åº¦ï¼ˆå­—é¢é‡ç±»å‹ï¼‰è¿›è¡Œç±»å‹çš„æŸ¥è¯¢

### **ç±»å‹å®ˆå«**

ç±»å‹æ§åˆ¶æµèƒ½åŠ›çš„ä¸è¶³ä½“ç°åœ¨ï¼š

```fsharp
function isString(input: unknown): input is string {
  return typeof input === "string";
}

function foo(input: string | number) {
  if (isString(input)) {
    // ç±»å‹â€œstring | numberâ€ä¸Šä¸å­˜åœ¨å±æ€§â€œreplaceâ€ã€‚
    (input).replace("linbudu", "linbudu599")
  }
  if (typeof input === 'number') { }
  // ...
}
```

`isString`çš„æå–æ˜¯å¯¹é€»è¾‘åˆ¤æ–­çš„å°è£…ï¼Œæ˜¯å¾ˆå¸¸è§çš„ï¼Œä½†æ˜¯è¿™é‡Œä¼šå‡ºç°é—®é¢˜

`isString`æ˜¯å¯¹äº`input`çš„ç±»å‹æ¨å¯¼ï¼Œä½†æ˜¯è¿™é‡Œçš„`isString`æ˜¯ä»åŸæœ‰çš„ç±»å‹æ§åˆ¶æµä¸­æå–å‡ºæ¥çš„ï¼Œ`Typescript`æ— æ³•å¤„ç†è·¨å‡½æ•°ä¸Šä¸‹æ–‡çš„ç±»å‹æ§åˆ¶æµï¼Œè¿™é‡Œéœ€è¦å¼•å…¥å…³é”®å­—**is**

é€šè¿‡**iså…³é”®å­— + é¢„æœŸç±»å‹** å¯¹**ç±»å‹å®ˆå«`isString`å‡½æ•°ï¼ˆ`isString`æ˜¯ç±»å‹å®ˆå«ï¼‰**è¿›è¡Œèƒ½åŠ›åŠ å¼ºï¼Œä½¿å¾—å®ƒä¼šè¢«è¿™ä¸ªç±»å‹å®ˆå«è°ƒç”¨æ–¹åç»­çš„ç±»å‹æ§åˆ¶æµåˆ†ææ”¶é›†åˆ°

### **åŸºäº`in`ä¸`instanceof`çš„ç±»å‹ä¿æŠ¤**

```fsharp
interface Foo {
	tpp: '123',
  foo: string;
  fooOnly: boolean;
  shared: number;
}

interface Bar {
	tpp: '234',
  bar: string;
  barOnly: boolean;
  shared: number;
}

function handle(input: Foo | Bar) {
  if ('foo' in input) {
    input.fooOnly;
  } else {
    input.barOnly;
  }
}

function handle2(input: Foo | Bar) {
  // æŠ¥é”™ï¼Œå¹¶æ²¡æœ‰èµ·åˆ°åŒºåˆ†çš„ä½œç”¨ï¼Œåœ¨ä¸¤ä¸ªä»£ç å—ä¸­éƒ½æ˜¯ Foo | Bar
  if (typeof input.diffType === 'string') {
    input.fooOnly;
  } else {
    input.barOnly;
  }
}

function handle1(input: Foo | Bar) {
  // æˆåŠŸï¼Œèµ·åˆ°åŒºåˆ†çš„ä½œç”¨ï¼Œå¿…é¡»ä½¿ç”¨å­—é¢é‡æ‰èƒ½åŒºåˆ†
  if (input.tpp === '123') {
    input.fooOnly;
  } else {
    input.barOnly;
  }
}
```

`foo`å±äº`Foo`æ¥å£çš„å¯è¾¨åˆ«å±æ€§ï¼Œå› ä¸ºè¿™ä¸ªå±æ€§æ˜¯`Bar`æ‰€ä¸å…·æœ‰çš„ï¼Œ**åˆ©ç”¨å…³é”®å­—`in`å¯¹ç±»å‹æ§åˆ¶æµè¿›è¡Œå¤„ç†**ï¼Œåœ¨è¿™é‡Œ`if`æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œ`input`ä¸€å®šå…·æœ‰`fooOnly`å±æ€§

å¯¹äºç›¸åŒå±æ€§ä¸åŒå±æ€§ç±»å‹çš„æƒ…å†µï¼Œä¸å¯ä»¥ä½¿ç”¨`typeof`è¿›è¡ŒåŒºåˆ†ï¼Œè€Œæ˜¯è¦åœ¨å­—é¢é‡çš„å±‚é¢æ‰èƒ½è¿›è¡ŒåŒºåˆ†

åŒæ ·çš„ï¼Œä¹Ÿå¯ä»¥**åˆ©ç”¨instanceofå¯¹ç±»å‹æ§åˆ¶æµè¿›è¡Œå¤„ç†**

```fsharp
class FooBase {}

class BarBase {}

class Foo extends FooBase {
  fooOnly() {}
}
class Bar extends BarBase {
  barOnly() {}
}

function handle(input: Foo | Bar) {
  if (input instanceof FooBase) {
    input.fooOnly();
  } else {
    input.barOnly();
  }
}
```

### **ç±»å‹æ–­è¨€å®ˆå«**

æ–­è¨€å®ˆå«å’Œç±»å‹å®ˆå«æœ€å¤§çš„ä¸åŒç‚¹åœ¨äºï¼Œåœ¨åˆ¤æ–­æ¡ä»¶ä¸é€šè¿‡æ—¶ï¼Œæ–­è¨€å®ˆå«éœ€è¦æŠ›å‡ºä¸€ä¸ªé”™è¯¯ï¼Œç±»å‹å®ˆå«åªéœ€è¦å‰”é™¤æ‰é¢„æœŸçš„ç±»å‹

## ç±»å‹ç³»ç»Ÿå…¼å®¹æ€§ä¸å±‚çº§

### ç»“æ„åŒ–ç±»å‹ç³»ç»Ÿä¸æ ‡ç§°ç±»å‹ç³»ç»Ÿ

`Typescript`å±äºç»“æ„åŒ–ç±»å‹ç³»ç»Ÿï¼ˆä¹Ÿå°±æ˜¯é¸­å­æ¨¡å‹ï¼‰ï¼Œå¦‚æœä¸€ä¸ªå¯¹è±¡ä¼šå«ã€ä¼šçˆ¬ï¼Œå…·æœ‰é¸­å­çš„ä¸€åˆ‡ç‰¹å¾ï¼Œé‚£ä¹ˆåœ¨è¯­è¨€å±‚é¢çœ‹æ¥ï¼Œå®ƒå°±æ˜¯é¸­å­ï¼ˆç±»å‹çš„å…¼å®¹æ€§åˆ¤æ–­ï¼‰ã€‚ä¸¤ç§ç±»å‹ç³»ç»Ÿçš„åŒºåˆ«å°±æ˜¯ä¸€ä¸ªæ˜¯åŸºäºç±»å‹ç»“æ„è¿›è¡Œå…¼å®¹æ€§æ¯”è¾ƒï¼Œä¸€ä¸ªæ˜¯åŸºäºç±»å‹åå­—è¿›è¡Œå…¼å®¹æ€§æ¯”è¾ƒ

**ç»“æ„æ˜¯ä¸ºäº†é™åˆ¶æ•°æ®çš„å¯ç”¨æ“ä½œä¸å®é™…æ„ä¹‰**ï¼Œåœ¨ä¸€äº›é¡¹ç›®ä¸­ï¼Œéœ€è¦å¯¹`Typescript`ç±»å‹ç³»ç»Ÿ**æ¨¡æ‹Ÿä¸ºæ ‡ç§°ç±»å‹ç³»ç»Ÿ**ï¼Œä¸»è¦çš„æ€è·¯æ˜¯æ·»åŠ ç±»å‹ä¿¡æ¯ï¼ˆç±»ä¼¼äºå…ƒä¿¡æ¯ï¼‰ï¼Œæ–¹æ³•æ˜¯ä½¿ç”¨é€»è¾‘ä¸ç±»å‹ç»“æ„

```fsharp
const nums1: renminbi = 100;
const nums2: meiyuan = 100;
function add(nums1: renminbi, nums2: renminbi) {return nums1 + nums2;}
// ä¸Šé¢è¿™æ ·ä¼šå‡ºé”™
// ä»ç±»å‹ç»“æ„ä¸Šæ·»åŠ é™„åŠ ç±»å‹ä¿¡æ¯
export declare class TagProtector<T extends string> {
  protected __tag__: T;
}
export type Nominal<T, U extends string> = T & TagProtector<U>;

export type CNY = Nominal<number, 'CNY'>;

export type USD = Nominal<number, 'USD'>;

const CNYCount = 100 as CNY;

const USDCount = 100 as USD;

function addCNY(source: CNY, input: CNY) {
  return (source + input) as CNY;
}

addCNY(CNYCount, CNYCount);

// æŠ¥é”™äº†ï¼
addCNY(CNYCount, USDCount);
```

### å‡½æ•°ç±»å‹çš„å…¼å®¹æ€§æ¯”è¾ƒ

`type DogFatory = (arg: Dog) â‡’ Dog`

å‚æ•°å¿…é¡»æ˜¯Dogçš„çˆ¶ç±»å‹æˆ–è€…Dogç±»å‹æœ¬èº«ï¼›è¿”å›å€¼å¿…é¡»æ˜¯Dogçš„å­ç±»å‹æˆ–è€…Dogç±»å‹æœ¬èº«

é€†å˜ä¸åå˜

åœ¨æ•°å­¦çš„è§’åº¦ä¸Šçœ‹ï¼Œéšç€ä¸€ä¸ªå€¼çš„å˜åŒ–ï¼Œå¦ä¸€ä¸ªå€¼å‘ç”Ÿä¸€è‡´çš„å˜åŒ–ï¼Œç§°ä¸ºåå˜ï¼›åä¹‹ç§°ä¸ºé€†å˜

åœ¨`Typescript`ä¸Šçœ‹ï¼Œå¦‚æœ`A<<B`ï¼ˆAæ˜¯Bçš„å­ç±»å‹ï¼‰ï¼Œé‚£ä¹ˆåå˜æ„å‘³ç€`Wrapper<A> <<  Wrapper<B>`

è¿™é‡Œçš„`Wrapper`å€¼çš„å°±æ˜¯ä»å•ä¸€ç±»å‹åˆ°å‡½æ•°ç±»å‹çš„åŒ…è£…

```fsharp
type AsFuncArgType<T> = (arg: T) => void;
type AsFuncReturnType<T> = (arg: unknown) => T;

// 1 æˆç«‹ï¼š(T -> Corgi) â‰¼ (T -> Dog)
type CheckReturnType = AsFuncReturnType<Corgi> extends AsFuncReturnType<Dog>
  ? 1
  : 2;

// 2 ä¸æˆç«‹ï¼š(Dog -> T) â‰¼ (Animal -> T)
type CheckArgType = AsFuncArgType<Dog> extends AsFuncArgType<Animal> ? 1 : 2;

```

**å‡½æ•°ç±»å‹çš„å‚æ•°ç±»å‹ä½¿ç”¨å­ç±»å‹é€†å˜çš„æ–¹å¼ç¡®å®šæ˜¯å¦æˆç«‹ï¼Œè¿”å›å€¼ç±»å‹ä½¿ç”¨å­ç±»å‹åå˜çš„æ–¹å¼ç¡®å®šæ˜¯å¦æˆç«‹**

**å¦‚æœè¦åˆ¤æ–­å‡½æ•°ç±»å‹çš„å…¼å®¹æ€§æ˜¯å¦æˆç«‹ï¼Œé‚£ä¹ˆå‚æ•°ç±»å‹å¿…é¡»æ˜¯åŸå‚æ•°ç±»å‹çš„çˆ¶ç±»å‹æˆ–è€…åŸç±»å‹æœ¬èº«ï¼Œè¿”å›å€¼ç±»å‹å¿…é¡»æ˜¯åŸè¿”å›å€¼ç±»å‹çš„å­ç±»å‹æˆ–è€…åŸç±»å‹æœ¬èº«**

åœ¨tsconfig.jsonä¸­ï¼Œé»˜è®¤çš„`strictFunctionTypes`ä¸ºfalseï¼Œéœ€è¦å¼€å¯ï¼Œä¹Ÿå°±æ˜¯è¯´é»˜è®¤æ˜¯åŒå˜çš„ï¼Œå…è®¸å‡½æ•°ç±»å‹å‚æ•°ç±»å‹å­ç±»å‹åå˜ï¼Œä¹Ÿå…è®¸å‡½æ•°ç±»å‹è¿”å›å€¼ç±»å‹å­ç±»å‹é€†å˜ã€‚è¿™æ˜¯å› ä¸ºåœ¨ä¸€äº›åœºæ™¯ä¸­

`Dog << Animal` ,`push`å‡½æ•°ä¸­çš„å‡½æ•°ç­¾åä¸º`(T) â‡’ void` ï¼Œé‚£ä¹ˆæ˜¯å¦æ„å‘³ç€`(Dog) â‡’ void << (Animal) â‡’ void` ä¸­`Dog`æ˜¯ä¸å¯ä»¥èµ‹å€¼ç»™`Animal`ï¼Œä½†æ˜¯åœ¨è¿™é‡Œæ˜æ˜¾ä¸æ˜¯çš„ï¼Œå› æ­¤æœ‰ä¸€äº›åœºæ™¯ä¸­å‡½æ•°ç±»å‹çš„æ£€æŸ¥æ˜¯åŒå˜çš„

PSï¼š

åœ¨ `TypeScript` `ESLint` ä¸­ï¼Œæœ‰è¿™ä¹ˆä¸€æ¡è§„åˆ™ï¼š[`method-signature-style`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftypescript-eslint%2Ftypescript-eslint%2Fblob%2Fmain%2Fpackages%2Feslint-plugin%2Fdocs%2Frules%2Fmethod-signature-style.md)ï¼Œå®ƒçš„æ„å›¾æ˜¯çº¦æŸåœ¨æ¥å£ä¸­å£°æ˜æ–¹æ³•æ—¶ï¼Œéœ€è¦ä½¿ç”¨Â **`property`**Â è€ŒéÂ **`method`**Â å½¢å¼ï¼š

```
// method å£°æ˜interface T1 {
func(arg: string): number;
}

// property å£°æ˜interface T2 {
  func: (arg: string) => number;
}

```

è¿›è¡Œå¦‚æ­¤çº¦æŸçš„åŸå› å³ï¼Œå¯¹äº `property` å£°æ˜ï¼Œæ‰èƒ½åœ¨å¼€å¯ä¸¥æ ¼å‡½æ•°ç±»å‹æ£€æŸ¥çš„æƒ…å†µä¸‹äº«å—åˆ°**åŸºäºé€†å˜çš„å‚æ•°ç±»å‹æ£€æŸ¥**ã€‚

```fsharp
interface Array<T> {
    push(...items: T[]): number;
}
```

`Array`æ¥å£çš„æ–¹æ³•ä½¿ç”¨`method`å½¢å¼å°±èƒ½è§„é¿æ‰åŸºäºé€†å˜çš„å‚æ•°ç±»å‹æ£€æŸ¥

### ç±»å‹å…¼å®¹æ€§åˆ¤æ–­çš„ä¸¤ç§æ–¹å¼

- èµ‹å€¼

`let a: number = 100;`

`let b: any;`

`let c: never;`

`b = a; // è¯´æ˜numberæ˜¯anyçš„å­ç±»å‹`

`c = a; // è¯´æ˜numberä¸æ˜¯neverçš„å­ç±»å‹`

- ç±»å‹

`type Result<T, U> = T extends U ? true: false;`

`type True = Result<string, any>;`

`type False = Result<unknown, any>;`

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/771242cd-e0bd-40da-aedf-1b7f0cad38df/Untitled.png)

## æ¡ä»¶ç±»å‹ä¸infer

### æ¡ä»¶ç±»å‹çš„åˆ†å¸ƒå¼ç‰¹æ€§

- æ˜¯å¦é€šè¿‡èŒƒå‹å‚æ•°ä¼ é€’è”åˆç±»å‹çš„å‚æ•°
- èŒƒå‹å‚æ•°æ˜¯å¦è¢«æ•°ç»„åŒ…è£¹äº†

å¯¹è”åˆç±»å‹çš„å‚æ•°è¿›è¡Œæ‹†åˆ†ï¼Œä¸€ä¸ªä¸€ä¸ªåœ°è¿›å…¥æ¡ä»¶ç±»å‹åˆ¤æ–­ä¸­å»

```fsharp
type Naked<T> = T extends boolean ? "Y" : "N";
type Wrapped<T> = [T] extends [boolean] ? "Y" : "N";

// "N" | "Y"
// é€šè¿‡èŒƒå‹å‚æ•°ä¼ é€’è”åˆç±»å‹çš„çš„å‚æ•°ï¼Œè§¦å‘åˆ†å¸ƒå¼ç‰¹æ€§
type Res3 = Naked<number | boolean>;
// èŒƒå‹å‚æ•°è¢«æ•°ç»„åŒ…è£¹äº†ï¼Œä¸ä¼šè§¦å‘åˆ†å¸ƒå¼ç‰¹æ€§
// "N"
type Res4 = Wrapped<number | boolean>;

```

## ç±»å‹ç¼–ç¨‹è¿›é˜¶

**å±æ€§ä¿®é¥°è¿›é˜¶**

- åŸºäºå·²çŸ¥éƒ¨åˆ†å±æ€§ä¿®é¥°
- æ·±å±‚ï¼ˆé€’å½’ï¼‰å±æ€§ä¿®é¥°

ç±»å‹ç¼–ç¨‹è¿›é˜¶åŸåˆ™ï¼šå°†å¤æ‚çš„å·¥å…·ç±»å‹è½¬æ¢ä¸ºç®€å•ã€åŸºç¡€çš„å·¥å…·ç±»å‹çš„ç»„åˆ

1. MarkPropsAsOptionalçš„ä½œç”¨æ˜¯å°†ä¸€ä¸ªå¯¹è±¡çš„éƒ¨åˆ†å±æ€§æ ‡æ³¨ä¸ºå¯é€‰ï¼ŒåŒæ ·çš„å¯ä»¥å°†ä¸€ä¸ªå¯¹è±¡çš„éƒ¨åˆ†å±æ€§æ ‡ä¸ºå¿…é€‰ã€åªè¯»ã€ä¸å¯ä¿®æ”¹ã€å¯ä¿®æ”¹ã€ä¸ä¸ºç©ºã€‚åˆ©ç”¨å†…ç½®ç±»å‹ **Requiredã€Readonlyã€Mutableã€Nullableã€NonNullableç­‰**

```fsharp
type Flatten<T extends object> = {[K in keyof T]: T[K]}
type MarkPropsAsOptional
<T extends object, 
K extends keyof T = keyof T> =  
Flatten<Partial<Pick<T, K>> & Omit<T, K>>

type MarkPropsAsOptionalStruct = MarkPropsAsOptional<
  {
    foo: string;
    bar: number;
    baz: boolean;
  },
  'bar'
>;
```

**ç»“æ„å·¥å…·ç±»å‹è¿›é˜¶**

- åŸºäºé”®å€¼ç±»å‹çš„ Pick ä¸ Omitï¼›
- å­ç»“æ„çš„äº’æ–¥å¤„ç†ã€‚

1.`PickByValueType`ä½œç”¨æ˜¯**åŸºäºæœŸæœ›çš„ç±»å‹å»æ‹¿åˆ°æ‰€æœ‰æ­¤ç±»å‹çš„å±æ€§åã€‚**

ä¹Ÿå°±æ˜¯è¯´å¯ä»¥æ‹¿åˆ°å¿…é€‰çš„å±æ€§åã€åªè¯»çš„å±æ€§åç­‰ç­‰

2.`Without`ä½œç”¨æ˜¯è¡¨ç¤ºä¸¤ä¸ªå¯¹è±¡å±æ€§ä¹‹é—´äº’æ–¥ï¼Œæœ‰ä½ æ²¡æˆ‘ï¼Œæœ‰æˆ‘æ²¡ä½ 

```fsharp
export type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

export type XOR<T, U> = (Without<T, U> & U) | (Without<U, T> & T);

type XORUser = XOR<VIP, CommonUser>;

expectType<XORUser>({
  vipExpires: 0,
});

expectType<XORUser>({
  promotionUsed: false,
});

// æŠ¥é”™ï¼Œè‡³å°‘éœ€è¦ä¸€ä¸ª
// @ts-expect-error
expectType<XORUser>({
});

// æŠ¥é”™ï¼Œä¸å…è®¸åŒæ—¶æ‹¥æœ‰
// @ts-expect-error
expectType<XORUser>({
  promotionUsed: false,
  vipExpires: 0,
});
```

**é›†åˆå·¥å…·ç±»å‹è¿›é˜¶**

ä»ä¸€ç»´åŸå§‹ç±»å‹é›†åˆï¼Œæ‰©å±•äºŒç»´çš„å¯¹è±¡ç±»å‹ï¼Œåœ¨å¯¹è±¡ç±»å‹ä¹‹é—´è¿›è¡Œäº¤å¹¶è¡¥å·®é›†çš„è¿ç®—ï¼Œä»¥åŠå¯¹åŒåå±æ€§çš„å„ç§å¤„ç†æƒ…å†µã€‚

**æ¨¡å¼åŒ¹é…å·¥å…·ç±»å‹è¿›é˜¶**

æ·±å±‚åµŒå¥—
