---
title: '🥫 TCP重传、滑动窗口、流量控制、拥塞控制'
date: '2022-08-24'
tags: ['TCP']
draft: false
summary: 'TCP重传、滑动窗口、流量控制、拥塞控制'
---

# TCP重传、滑动窗口、流量控制、拥塞控制

## TCP重传

### 超时重传

TCP在两种条件下会触发超时重传：

1.数据包丢失

2.确认应答丢失

如何确认超时重传的时间？

RTO(Retransmission Timeout)由平滑RTT(采样后加权平均的RTT(Round-Trip Timeout)时间)和最新的RTT 加权得到。每当遇到超时重传的时候，都会是上一次重传时间的两倍，说明网络环境差，会导致超时重发的时间越来越长

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00ab347f-41e5-43a1-88ca-9f66c42e7ca6/Untitled.png)

SRTT是平滑RTT，DevRTT是平滑RTT与最新RTT的差距

在 Linux 下，**α = 0.125，β = 0.25， μ = 1，∂ = 4**

### 快速重传

**快速重传是以数据驱动的重传机制**，而不是时间

当发送方接收到三个ACK=2的确认，会重发序列号为2的报文

关键的问题是我们应该重传所有的报文，还是只重传一个报文呢？

### SACK

**SACK是选择*性重传的重传机制***

我们可以在TCP报文头部的「选项」字段添加SACK，它可以将接收方已经接收到的数据包发送到发送方，这样的话，发送方只需要发送接收方没有接收到的TCP报文

当发送方接收到三个ACK=2的确认，触发快速重传机制，发现接收方的TCP报文的SACK字段已经接收到序列号为3，4，5，6的报文，那么发送方只需要重发序列号为2的报文即可

双方必须开启SACK，通过Linux参数`net.ipv4.tcp_sack`开启（Linux2.4默认开启）

### D-SACK

**D-SACK使用SACK告诉发送方哪些数据已经被重复接收的**

D-SACK的意义是通过告诉发送方哪些数据已经被重复接收，从而让发送方知晓重传的原因：1.ACK报文丢失 2.网络拥塞，数据包被延迟

通过Linux参数`net.ipv4.tcp_dsack`开启（Linux2.4默认开启）

## 滑动窗口

**滑动窗口指的是无需等待确认应答的情况下，继续发送数据的最大值**

滑动窗口想要解决一问一答式的请求应答模式下，由于网络拥塞或是服务端忙导致效率低的问题

TCP头部的「Window」字段就是接收方告诉发送方，自己还有多少缓冲区可以接收数据。于是发送方可以按照这个缓冲区大小去发送数据，而不会导致接收方接受不过来

**发送方的滑动窗口**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c635b48b-57b7-4d21-b052-2c042a2da160/Untitled.png)

发送方的滑动窗口分为四个部分，TCP滑动方案是采用三个指针在程序中表示滑动窗口的四个部分：两个绝对指针和一个相对指针，分别是SYN_UNA指向#2的第一个字节，SYN_NXT指向#3的第一个字节，还有一个相对指针由SYN_UNA+ SYN_WN得到指向#4的第一个字节

- SYN_UNA
- SYN_NXT
- SYN_WND

**接收方的滑动窗口**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77446121-9753-49f6-8333-0a36174ab640/Untitled.png)

接收方的滑动窗口分为三个部分，TCP滑动方案是采用两个指针在程序中表示滑动窗口的三个部分：一个绝对指针和一个相对指针，分别是RCV_NXT指向#3的第一个字节，还有一个相对指针由RCV_NXT+ RCV_WND得到指向#4的第一个字节

- RSV_NXT
- RSV_WND

## 流量控制

**停等协议→流水线式的协议**

TCP提供了一种机制，**让「发送方」根据「接收方」实际接收数据的能力去控制发送的数据量——流量控制，避免发送方的数据包占满接收方的缓存空间**

我们去理解发送-接收的流程，为了方便理解，我们假设发送方与接收方的滑动窗口的大小不变，传输过程中默认滑动窗口大小不发生变化(200)

- 发送方发送120字节的数据后，SYN_NXT向右移动120，Usable表示可用窗口减少为80字节
- 发送方接收到120字节的数据后，SYN_UNA向右移动120，Usable增加至200字节
- 接收方接收到120字节的数据后，发送ACK报文，RSV_NXT向右移动120，接收方滑动窗口大小不变

下面我们考虑滑动窗口改变的情形，为什么滑动窗口大小会发生改变呢？

发送方与接收方的滑动窗口的大小实际上是由操作系统的缓冲区决定的，当操作系统没有及时读取缓冲区内容时，会发生滑动窗口变小的情形：

- 发送方发送200字节的数据后，接收方接收数据将数据放入内存缓冲区，此时操作系统并没有时间处理缓冲区的内容，那么接收方的滑动窗口大小变为0字节，将滑动窗口大小通告给发送方
- 发送方无法发送数据，会定时发送滑动窗口勘测报文，直到可以发送数据
- 操作系统处理完缓存区的数据，此时接收方回发一个ACK报文告知发送方滑动窗口大小，请求继续接收数据
- 若此ACK报文丢失，由于发送方定时发送勘测滑动窗口报文，双方不会陷入死锁

当操作系统足够繁忙时，可以直接减少操作系统的缓冲区的大小，但是TCP不允许同时减少缓冲区与滑动窗口大小，因为这有可能会导致**丢包**的问题

**糊弄窗口综合症**

当接收方操作系统繁忙时，不及时拿走操作系统缓冲区的数据，会导致滑动窗口越来越小。接收方告诉发送方有多少空余空间，发送方就发送多少，这就是糊弄窗口综合症。

因为TCP头部数据至少占20字节，那么为了几字节的数据去发送，显然是不值得的

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/32bb3901-1047-4a02-b347-c34daf9249ed/Untitled.png)

上图就是滑动窗口越来越小的过程

为了避免出现糊弄窗口综合症（滑动窗口越来越小，发送方可以发送小数据而不是大数据），我们应该怎么做呢？

接收方的策略：

当滑动窗口大小小于Math.min(MSS, 操作系统缓存空间/2)时，滑动窗口大小会置为0，阻止发送方继续发送数据

发送方的策略：

使用**Nagle**算法，只有满足其中一个条件才会发送数据：

1.接收到ACK报文

2.滑动窗口大小大于MSS

## 拥塞控制

**拥塞控制的目的是为了避免发送方的数据报充满整个网络环境**

拥塞窗口cwnd是发送方维护的一个状态变量，反映出网络的拥塞情况，**是发送窗口与接收窗口的最小值**

拥塞窗口的大小是根据ACK报文的接收决定的，接收到ACK报文，说明网络状况良好，拥塞窗口大小增大；没有接收到ACK报文，触发超时重传，说明网络状况糟糕，拥塞窗口大小减少。拥塞窗口为1代表可以发送一个MSS大小的数据报

拥塞窗口的四种算法：

### **慢启动**

规则：每次接收到一个ACK报文，cwnd = cwnd+1

触发条件：cwnd小于慢启动门限ssthresh

### **拥塞避免**

规则：每次接收到一个ACK报文，cwnd = cwnd + 1/ cwnd

触发条件：cwnd大于等于慢启动门限，且没有触发超时重传或快速重传

### **拥塞发生**

发生拥塞时（没有接收到ACK时），触发超时重传机制或者快速重传机制

若触发超时重传机制，那么说明网络拥塞情况比较严重

规则：

1.ssthresh = cwnd / 2；

2.cwnd = 1；

3.进入慢启动算法

若触发快速重传机制，那么说明网络出现拥塞，但是仍然能收到三个ACK报文，拥塞状况不算严重

规则： 

1.cwnd = cwnd /2 ；

2.ssthresh = cwnd； 

3.进入快速恢复算法

### **快速恢复**

规则：

1.cwnd = cwnd + 3（意味着接收到三个重复的ACK报文）

2.重新丢失的报文

3.若接收到重复的ACK报文，cwnd = cwnd +1

4.若接收到新的ACK报文，那么说明网络拥塞状况以及良好，ssthresh恢复为原来的值，快速恢复结束